{"version":3,"sources":["../../../packages/core/src/index.js"],"names":["alphabet","maxHashLength","NaN","i","maxHash","anyBase","BIN","slice","Array","join","push","length","noop","isArrayBuffer","test","Object","prototype","toString","call","toLowerCase","indexOf","bufferFromArrayBuffer","arrayBuffer","buffer","Buffer","alloc","byteLength","view","Uint8Array","loadFromURL","options","cb","err","response","data","headers","url","location","isBuffer","msg","statusCode","Error","loadBufferFromPath","src","fs","readFile","match","isRawRGBAData","obj","width","height","Uint8ClampedArray","makeRGBABufferFromRGB","rgbaBuffer","allocUnsafe","j","emptyBitmap","PJW","args","MIME_PNG","path","write","mime","getBase64","getBuffer","getBufferAsync","PJWInstance","finish","evData","methodName","setTimeout","emitError","emitMulti","parseInt","w","h","_background","cssColorToHex","throwError","bitmap","writeUInt32BE","parseBitmap","original","from","_quality","_deflateLevel","_deflateStrategy","_filterType","_rgba","_originalMime","imageData","isRGBA","extraConstructor","__extraConstructors","find","c","Promise","resolve","reject","run","then","bool","eventName","assign","emit","getMIME","MIME","getExtension","createWriteStream","getType","pathObj","Path","parse","dir","mkdirp","sync","stream","on","end","AUTO","x","y","edgeHandling","xi","yi","EDGE_EXTEND","Math","round","EDGE_WRAP","EventEmitter","addConstants","constants","entries","forEach","name","value","addPJWMethods","methods","composite","appendConstructorOption","read","image","create","limit255","n","max","min","PJWEvMethod","evName","method","evNameBefore","evNameAfter","replace","wrappedCb","apply","result","error","clone","PJWEvChange","hex","f","process","env","ENVIRONMENT","gl","window","self"],"mappings":"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AAN,CAAT,KACKiE,OAAO,CAAC4C,KAAD,CAAP;AACN,KAHD;AAID,GALM,CAAP;AAMD,CAPD;;AASApF,GAAG,CAACqF,MAAJ,GAAarF,GAAG,CAACmF,IAAjB,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AACAnF,GAAG,CAACsF,QAAJ,GAAe,UAASC,CAAT,EAAY;AACzBA,EAAAA,CAAC,GAAGlB,IAAI,CAACmB,GAAL,CAASD,CAAT,EAAY,CAAZ,CAAJ;AACAA,EAAAA,CAAC,GAAGlB,IAAI,CAACoB,GAAL,CAASF,CAAT,EAAY,GAAZ,CAAJ;AAEA,SAAOA,CAAP;AACD,CALD;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA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","sourcesContent":["import fs from 'fs';\nimport Path from 'path';\nimport EventEmitter from 'events';\n\nimport { isNodePattern, throwError, scan, scanIterator } from \"../../utils/src/index.js\"//'@PJW/utils';\nimport anyBase from 'any-base';\nimport mkdirp from 'mkdirp';\n//import pixelMatch from 'pixelmatch';\n//import tinyColor from 'tinycolor2';\n\n//import ImagePHash from './modules/phash';\nimport request from './request';\n\nimport composite from './composite';\nimport promisify from './utils/promisify';\nimport * as MIME from './utils/mime';\nimport { parseBitmap, getBuffer, getBufferAsync } from './utils/image-bitmap';\nimport * as constants from './constants';\n\nconst alphabet =\n  '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_';\n\n// an array storing the maximum string length of hashes at various bases\n// 0 and 1 do not exist as possible hash lengths\nconst maxHashLength = [NaN, NaN];\n\nfor (let i = 2; i < 65; i++) {\n  const maxHash = anyBase(anyBase.BIN, alphabet.slice(0, i))(\n    new Array(64 + 1).join('1')\n  );\n  maxHashLength.push(maxHash.length);\n}\n\n// no operation\nfunction noop() {}\n\n// error checking methods\n\nfunction isArrayBuffer(test) {\n  return (\n    Object.prototype.toString\n      .call(test)\n      .toLowerCase()\n      .indexOf('arraybuffer') > -1\n  );\n}\n\n// Prepare a Buffer object from the arrayBuffer. Necessary in the browser > node conversion,\n// But this function is not useful when running in node directly\nfunction bufferFromArrayBuffer(arrayBuffer) {\n  const buffer = Buffer.alloc(arrayBuffer.byteLength);\n  const view = new Uint8Array(arrayBuffer);\n\n  for (let i = 0; i < buffer.length; ++i) {\n    buffer[i] = view[i];\n  }\n\n  return buffer;\n}\n\nfunction loadFromURL(options, cb) {\n  request(options, (err, response, data) => {\n    if (err) {\n      return cb(err);\n    }\n\n    if ('headers' in response && 'location' in response.headers) {\n      options.url = response.headers.location;\n      return loadFromURL(options, cb);\n    }\n\n    if (typeof data === 'object' && Buffer.isBuffer(data)) {\n      return cb(null, data);\n    }\n\n    const msg =\n      'Could not load Buffer from <' +\n      options.url +\n      '> ' +\n      '(HTTP: ' +\n      response.statusCode +\n      ')';\n\n    return new Error(msg);\n  });\n}\n\nfunction loadBufferFromPath(src, cb) {\n  if (\n    fs &&\n    typeof fs.readFile === 'function' &&\n    !src.match(/^(http|ftp)s?:\\/\\/./)\n  ) {\n    fs.readFile(src, cb);\n  } else {\n    loadFromURL({ url: src }, cb);\n  }\n}\n\nfunction isRawRGBAData(obj) {\n  return (\n    obj &&\n    typeof obj === 'object' &&\n    typeof obj.width === 'number' &&\n    typeof obj.height === 'number' &&\n    (Buffer.isBuffer(obj.data) ||\n      obj.data instanceof Uint8Array ||\n      (typeof Uint8ClampedArray === 'function' &&\n        obj.data instanceof Uint8ClampedArray)) &&\n    (obj.data.length === obj.width * obj.height * 4 ||\n      obj.data.length === obj.width * obj.height * 3)\n  );\n}\n\nfunction makeRGBABufferFromRGB(buffer) {\n  if (buffer.length % 3 !== 0) {\n    throw new Error('Buffer length is incorrect');\n  }\n\n  const rgbaBuffer = Buffer.allocUnsafe((buffer.length / 3) * 4);\n  let j = 0;\n\n  for (let i = 0; i < buffer.length; i++) {\n    rgbaBuffer[j] = buffer[i];\n\n    if ((i + 1) % 3 === 0) {\n      rgbaBuffer[++j] = 255;\n    }\n\n    j++;\n  }\n\n  return rgbaBuffer;\n}\n\nconst emptyBitmap = {\n  data: null,\n  width: null,\n  height: null\n};\n\n/**\n * PJW constructor (from a file)\n * @param path a path to the image\n * @param {function(Error, PJW)} cb (optional) a function to call when the image is parsed to a bitmap\n */\n\n/**\n * PJW constructor (from a url with options)\n * @param options { url, otherOptions}\n * @param {function(Error, PJW)} cb (optional) a function to call when the image is parsed to a bitmap\n */\n\n/**\n * PJW constructor (from another PJW image or raw image data)\n * @param image a PJW image to clone\n * @param {function(Error, PJW)} cb a function to call when the image is parsed to a bitmap\n */\n\n/**\n * PJW constructor (from a Buffer)\n * @param data a Buffer containing the image data\n * @param {function(Error, PJW)} cb a function to call when the image is parsed to a bitmap\n */\n\n/**\n * PJW constructor (to generate a new image)\n * @param w the width of the image\n * @param h the height of the image\n * @param {function(Error, PJW)} cb (optional) a function to call when the image is parsed to a bitmap\n */\n\n/**\n * PJW constructor (to generate a new image)\n * @param w the width of the image\n * @param h the height of the image\n * @param background color to fill the image with\n * @param {function(Error, PJW)} cb (optional) a function to call when the image is parsed to a bitmap\n */\n\nclass PJW extends EventEmitter {\n  // An object representing a bitmap in memory, comprising:\n  //  - data: a buffer of the bitmap data\n  //  - width: the width of the image in pixels\n  //  - height: the height of the image in pixels\n  bitmap = emptyBitmap;\n\n  // Default colour to use for new pixels\n  _background = 0x00000000;\n\n  // Default MIME is PNG\n  _originalMime = PJW.MIME_PNG;\n\n  // Exif data for the image\n  _exif = null;\n\n  // Whether Transparency supporting formats will be exported as RGB or RGBA\n  _rgba = true;\n\n  constructor(...args) {\n    super();\n\n    const PJWInstance = this;\n    let cb = noop;\n\n    if (isArrayBuffer(args[0])) {\n      args[0] = bufferFromArrayBuffer(args[0]);\n    }\n\n    function finish(...args) {\n      const [err] = args;\n      const evData = err || {};\n      evData.methodName = 'constructor';\n\n      setTimeout(() => {\n        // run on next tick.\n        if (err && cb === noop) {\n          PJWInstance.emitError('constructor', err);\n        } else if (!err) {\n          PJWInstance.emitMulti('constructor', 'initialized');\n        }\n\n        cb.call(PJWInstance, ...args);\n      }, 1);\n    }\n\n    if (\n      (typeof args[0] === 'number' && typeof args[1] === 'number') ||\n      (parseInt(args[0], 10) && parseInt(args[1], 10))\n    ) {\n      // create a new image\n      const w = parseInt(args[0], 10);\n      const h = parseInt(args[1], 10);\n      cb = args[2];\n\n      // with a hex color\n      if (typeof args[2] === 'number') {\n        this._background = args[2];\n        cb = args[3];\n      }\n\n      // with a css color\n      if (typeof args[2] === 'string') {\n        this._background = PJW.cssColorToHex(args[2]);\n        cb = args[3];\n      }\n\n      if (typeof cb === 'undefined') {\n        cb = noop;\n      }\n\n      if (typeof cb !== 'function') {\n        return throwError.call(this, 'cb must be a function', finish);\n      }\n\n      this.bitmap = {\n        data: Buffer.alloc(w * h * 4),\n        width: w,\n        height: h\n      };\n\n      for (let i = 0; i < this.bitmap.data.length; i += 4) {\n        this.bitmap.data.writeUInt32BE(this._background, i);\n      }\n\n      finish(null, this);\n    } else if (typeof args[0] === 'object' && args[0].url) {\n      cb = args[1] || noop;\n\n      if (typeof cb !== 'function') {\n        return throwError.call(this, 'cb must be a function', finish);\n      }\n\n      loadFromURL(args[0], (err, data) => {\n        if (err) {\n          return throwError.call(this, err, finish);\n        }\n\n        this.parseBitmap(data, args[0].url, finish);\n      });\n    } else if (args[0] instanceof PJW) {\n      // clone an existing PJW\n      const [original] = args;\n      cb = args[1];\n\n      if (typeof cb === 'undefined') {\n        cb = noop;\n      }\n\n      if (typeof cb !== 'function') {\n        return throwError.call(this, 'cb must be a function', finish);\n      }\n\n      this.bitmap = {\n        data: Buffer.from(original.bitmap.data),\n        width: original.bitmap.width,\n        height: original.bitmap.height\n      };\n\n      this._quality = original._quality;\n      this._deflateLevel = original._deflateLevel;\n      this._deflateStrategy = original._deflateStrategy;\n      this._filterType = original._filterType;\n      this._rgba = original._rgba;\n      this._background = original._background;\n      this._originalMime = original._originalMime;\n\n      finish(null, this);\n    } else if (isRawRGBAData(args[0])) {\n      const [imageData] = args;\n      cb = args[1] || noop;\n\n      const isRGBA =\n        imageData.width * imageData.height * 4 === imageData.data.length;\n      const buffer = isRGBA\n        ? Buffer.from(imageData.data)\n        : makeRGBABufferFromRGB(imageData.data);\n\n      this.bitmap = {\n        data: buffer,\n        width: imageData.width,\n        height: imageData.height\n      };\n\n      finish(null, this);\n    } else if (typeof args[0] === 'string') {\n      // read from a path\n      const path = args[0];\n      cb = args[1];\n\n      if (typeof cb === 'undefined') {\n        cb = noop;\n      }\n\n      if (typeof cb !== 'function') {\n        return throwError.call(this, 'cb must be a function', finish);\n      }\n\n      loadBufferFromPath(path, (err, data) => {\n        if (err) {\n          return throwError.call(this, err, finish);\n        }\n\n        this.parseBitmap(data, path, finish);\n      });\n    } else if (typeof args[0] === 'object' && Buffer.isBuffer(args[0])) {\n      // read from a buffer\n      const data = args[0];\n      cb = args[1];\n\n      if (typeof cb !== 'function') {\n        return throwError.call(this, 'cb must be a function', finish);\n      }\n\n      this.parseBitmap(data, null, finish);\n    } else {\n      // Allow client libs to add new ways to build a PJW object.\n      // Extra constructors must be added by `PJW.appendConstructorOption()`\n      cb = args[args.length - 1];\n\n      if (typeof cb !== 'function') {\n        // TODO: try to solve the args after cb problem.\n        cb = args[args.length - 2];\n\n        if (typeof cb !== 'function') {\n          cb = noop;\n        }\n      }\n\n      const extraConstructor = PJW.__extraConstructors.find(c =>\n        c.test(...args)\n      );\n\n      if (extraConstructor) {\n        new Promise((resolve, reject) =>\n          extraConstructor.run.call(this, resolve, reject, ...args)\n        )\n          .then(() => finish(null, this))\n          .catch(finish);\n      } else {\n        return throwError.call(\n          this,\n          'No matching constructor overloading was found. ' +\n            'Please see the docs for how to call the PJW constructor.',\n          finish\n        );\n      }\n    }\n  }\n\n  /**\n   * Parse a bitmap with the loaded image types.\n   *\n   * @param {Buffer} data raw image data\n   * @param {string} path optional path to file\n   * @param {function(Error, PJW)} finish (optional) a callback for when complete\n   * @memberof PJW\n   */\n  parseBitmap(data, path, finish) {\n    parseBitmap.call(this, data, null, finish);\n  }\n\n  /**\n   * Sets the type of the image (RGB or RGBA) when saving in a format that supports transparency (default is RGBA)\n   * @param {boolean} bool A Boolean, true to use RGBA or false to use RGB\n   * @param {function(Error, PJW)} cb (optional) a callback for when complete\n   * @returns {PJW} this for chaining of methods\n   */\n  rgba(bool, cb) {\n    if (typeof bool !== 'boolean') {\n      return throwError.call(\n        this,\n        'bool must be a boolean, true for RGBA or false for RGB',\n        cb\n      );\n    }\n\n    this._rgba = bool;\n\n    if (isNodePattern(cb)) {\n      cb.call(this, null, this);\n    }\n\n    return this;\n  }\n\n  /**\n   * Emit for multiple listeners\n   * @param {string} methodName name of the method to emit an error for\n   * @param {string} eventName name of the eventName to emit an error for\n   * @param {object} data to emit\n   */\n  emitMulti(methodName, eventName, data = {}) {\n    data = Object.assign(data, { methodName, eventName });\n    this.emit('any', data);\n\n    if (methodName) {\n      this.emit(methodName, data);\n    }\n\n    this.emit(eventName, data);\n  }\n\n  emitError(methodName, err) {\n    this.emitMulti(methodName, 'error', err);\n  }\n\n  /**\n   * Get the current height of the image\n   * @return {number} height of the image\n   */\n  getHeight() {\n    return this.bitmap.height;\n  }\n\n  /**\n   * Get the current width of the image\n   * @return {number} width of the image\n   */\n  getWidth() {\n    return this.bitmap.width;\n  }\n\n  /**\n   * Nicely format PJW object when sent to the console e.g. console.log(image)\n   * @returns {string} pretty printed\n   */\n  inspect() {\n    return (\n      '<PJW ' +\n      (this.bitmap === emptyBitmap\n        ? 'pending...'\n        : this.bitmap.width + 'x' + this.bitmap.height) +\n      '>'\n    );\n  }\n\n  /**\n   * Nicely format PJW object when converted to a string\n   * @returns {string} pretty printed\n   */\n  toString() {\n    return '[object PJW]';\n  }\n\n  /**\n   * Returns the original MIME of the image (default: \"image/png\")\n   * @returns {string} the MIME\n   */\n  getMIME() {\n    const mime = this._originalMime || PJW.MIME_PNG;\n\n    return mime;\n  }\n\n  /**\n   * Returns the appropriate file extension for the original MIME of the image (default: \"png\")\n   * @returns {string} the file extension\n   */\n  getExtension() {\n    const mime = this.getMIME();\n\n    return MIME.getExtension(mime);\n  }\n\n  /**\n   * Writes the image to a file\n   * @param {string} path a path to the destination file\n   * @param {function(Error, PJW)} cb (optional) a function to call when the image is saved to disk\n   * @returns {PJW} this for chaining of methods\n   */\n  write(path, cb) {\n    if (!fs || !fs.createWriteStream) {\n      throw new Error(\n        'Cant access the filesystem. You can use the getBase64 method.'\n      );\n    }\n\n    if (typeof path !== 'string') {\n      return throwError.call(this, 'path must be a string', cb);\n    }\n\n    if (typeof cb === 'undefined') {\n      cb = noop;\n    }\n\n    if (typeof cb !== 'function') {\n      return throwError.call(this, 'cb must be a function', cb);\n    }\n\n    const mime = MIME.getType(path) || this.getMIME();\n    const pathObj = Path.parse(path);\n\n    if (pathObj.dir) {\n      mkdirp.sync(pathObj.dir);\n    }\n\n    this.getBuffer(mime, (err, buffer) => {\n      if (err) {\n        return throwError.call(this, err, cb);\n      }\n\n      const stream = fs.createWriteStream(path);\n\n      stream\n        .on('open', () => {\n          stream.write(buffer);\n          stream.end();\n        })\n        .on('error', err => {\n          return throwError.call(this, err, cb);\n        });\n      stream.on('finish', () => {\n        cb.call(this, null, this);\n      });\n    });\n\n    return this;\n  }\n\n  writeAsync = path => promisify(this.write, this, path);\n\n  /**\n   * Converts the image to a base 64 string\n   * @param {string} mime the mime type of the image data to be created\n   * @param {function(Error, PJW)} cb a Node-style function to call with the buffer as the second argument\n   * @returns {PJW} this for chaining of methods\n   */\n  async getBase64(mime, cb) {\n    if (mime === PJW.AUTO) {\n      // allow auto MIME detection\n      mime = this.getMIME();\n    }\n\n    if (typeof mime !== 'string') {\n      return throwError.call(this, 'mime must be a string', cb);\n    }\n\n    if (typeof cb !== 'function') {\n      return throwError.call(this, 'cb must be a function', cb);\n    }\n\n    await this.getBuffer(mime, function(err, data) {\n      if (err) {\n        return throwError.call(this, err, cb);\n      }\n      const src = 'data:' + mime + ';base64,' + data.toString('base64');\n      cb.call(this, null, src);\n    });\n\n    return this;\n  }\n\n  getBase64Async = mime => promisify(this.getBase64, this, mime);\n\n  // /**\n  //  * Generates a perceptual hash of the image <https://en.wikipedia.org/wiki/Perceptual_hashing>. And pads the string. Can configure base.\n  //  * @param {number} base (optional) a number between 2 and 64 representing the base for the hash (e.g. 2 is binary, 10 is decimal, 16 is hex, 64 is base 64). Defaults to 64.\n  //  * @param {function(Error, PJW)} cb (optional) a callback for when complete\n  //  * @returns {string} a string representing the hash\n  //  */\n  // hash(base, cb) {\n  //   base = base || 64;\n\n  //   if (typeof base === 'function') {\n  //     cb = base;\n  //     base = 64;\n  //   }\n\n  //   if (typeof base !== 'number') {\n  //     return throwError.call(this, 'base must be a number', cb);\n  //   }\n\n  //   if (base < 2 || base > 64) {\n  //     return throwError.call(\n  //       this,\n  //       'base must be a number between 2 and 64',\n  //       cb\n  //     );\n  //   }\n\n  //   let hash = this.pHash();\n  //   hash = anyBase(anyBase.BIN, alphabet.slice(0, base))(hash);\n\n  //   while (hash.length < maxHashLength[base]) {\n  //     hash = '0' + hash; // pad out with leading zeros\n  //   }\n\n  //   if (isNodePattern(cb)) {\n  //     cb.call(this, null, hash);\n  //   }\n\n  //   return hash;\n  // }\n\n  // /**\n  //  * Calculates the perceptual hash\n  //  * @returns {number} the perceptual hash\n  //  */\n  // pHash() {\n  //   const pHash = new ImagePHash();\n  //   return pHash.getHash(this);\n  // }\n\n  // /**\n  //  * Calculates the hamming distance of the current image and a hash based on their perceptual hash\n  //  * @param {hash} compareHash hash to compare to\n  //  * @returns {number} a number ranging from 0 to 1, 0 means they are believed to be identical\n  //  */\n  // distanceFromHash(compareHash) {\n  //   const pHash = new ImagePHash();\n  //   const currentHash = pHash.getHash(this);\n\n  //   return pHash.distance(currentHash, compareHash);\n  // }\n\n  /**\n   * Converts the image to a buffer\n   * @param {string} mime the mime type of the image buffer to be created\n   * @param {function(Error, PJW)} cb a Node-style function to call with the buffer as the second argument\n   * @returns {PJW} this for chaining of methods\n   */\n  getBuffer = getBuffer;\n\n  getBufferAsync = getBufferAsync;\n\n  /**\n   * Returns the offset of a pixel in the bitmap buffer\n   * @param {number} x the x coordinate\n   * @param {number} y the y coordinate\n   * @param {string} edgeHandling (optional) define how to sum pixels from outside the border\n   * @param {number} cb (optional) a callback for when complete\n   * @returns {number} the index of the pixel or -1 if not found\n   */\n  getPixelIndex(x, y, edgeHandling, cb) {\n    let xi;\n    let yi;\n\n    if (typeof edgeHandling === 'function' && typeof cb === 'undefined') {\n      cb = edgeHandling;\n      edgeHandling = null;\n    }\n\n    if (!edgeHandling) {\n      edgeHandling = PJW.EDGE_EXTEND;\n    }\n\n    if (typeof x !== 'number' || typeof y !== 'number') {\n      return throwError.call(this, 'x and y must be numbers', cb);\n    }\n\n    // round input\n    x = Math.round(x);\n    y = Math.round(y);\n    xi = x;\n    yi = y;\n\n    if (edgeHandling === PJW.EDGE_EXTEND) {\n      if (x < 0) xi = 0;\n      if (x >= this.bitmap.width) xi = this.bitmap.width - 1;\n      if (y < 0) yi = 0;\n      if (y >= this.bitmap.height) yi = this.bitmap.height - 1;\n    }\n\n    if (edgeHandling === PJW.EDGE_WRAP) {\n      if (x < 0) {\n        xi = this.bitmap.width + x;\n      }\n\n      if (x >= this.bitmap.width) {\n        xi = x % this.bitmap.width;\n      }\n\n      if (y < 0) {\n        xi = this.bitmap.height + y;\n      }\n\n      if (y >= this.bitmap.height) {\n        yi = y % this.bitmap.height;\n      }\n    }\n\n    let i = (this.bitmap.width * yi + xi) << 2;\n\n    // if out of bounds index is -1\n    if (xi < 0 || xi >= this.bitmap.width) {\n      i = -1;\n    }\n\n    if (yi < 0 || yi >= this.bitmap.height) {\n      i = -1;\n    }\n\n    if (isNodePattern(cb)) {\n      cb.call(this, null, i);\n    }\n\n    return i;\n  }\n\n  // /**\n  //  * Returns the hex colour value of a pixel\n  //  * @param {number} x the x coordinate\n  //  * @param {number} y the y coordinate\n  //  * @param {function(Error, PJW)} cb (optional) a callback for when complete\n  //  * @returns {number} the color of the pixel\n  //  */\n  // getPixelColor(x, y, cb) {\n  //   if (typeof x !== 'number' || typeof y !== 'number')\n  //     return throwError.call(this, 'x and y must be numbers', cb);\n\n  //   // round input\n  //   x = Math.round(x);\n  //   y = Math.round(y);\n\n  //   const idx = this.getPixelIndex(x, y);\n  //   const hex = this.bitmap.data.readUInt32BE(idx);\n\n  //   if (isNodePattern(cb)) {\n  //     cb.call(this, null, hex);\n  //   }\n\n  //   return hex;\n  // }\n\n  // getPixelColour = this.getPixelColor;\n\n  // /**\n  //  * Returns the hex colour value of a pixel\n  //  * @param {number} hex color to set\n  //  * @param {number} x the x coordinate\n  //  * @param {number} y the y coordinate\n  //  * @param {function(Error, PJW)} cb (optional) a callback for when complete\n  //  * @returns {number} the index of the pixel or -1 if not found\n  //  */\n  // setPixelColor(hex, x, y, cb) {\n  //   if (\n  //     typeof hex !== 'number' ||\n  //     typeof x !== 'number' ||\n  //     typeof y !== 'number'\n  //   )\n  //     return throwError.call(this, 'hex, x and y must be numbers', cb);\n\n  //   // round input\n  //   x = Math.round(x);\n  //   y = Math.round(y);\n\n  //   const idx = this.getPixelIndex(x, y);\n  //   this.bitmap.data.writeUInt32BE(hex, idx);\n\n  //   if (isNodePattern(cb)) {\n  //     cb.call(this, null, this);\n  //   }\n\n  //   return this;\n  // }\n\n  // setPixelColour = this.setPixelColor;\n\n  // /**\n  //  * Determine if the image contains opaque pixels.\n  //  * @return {boolean} hasAlpha whether the image contains opaque pixels\n  //  */\n  // hasAlpha() {\n  //   for (let yIndex = 0; yIndex < this.bitmap.height; yIndex++) {\n  //     for (let xIndex = 0; xIndex < this.bitmap.width; xIndex++) {\n  //       const idx = (this.bitmap.width * yIndex + xIndex) << 2;\n  //       const alpha = this.bitmap.data[idx + 3];\n\n  //       if (alpha !== 0xff) {\n  //         return true;\n  //       }\n  //     }\n  //   }\n\n  //   return false;\n  // }\n\n  /**\n   * Iterate scan through a region of the bitmap\n   * @param {number} x the x coordinate to begin the scan at\n   * @param {number} y the y coordinate to begin the scan at\n   * @param w the width of the scan region\n   * @param h the height of the scan region\n   * @returns {IterableIterator<{x: number, y: number, idx: number, image: PJW}>}\n   */\n  scanIterator(x, y, w, h) {\n    if (typeof x !== 'number' || typeof y !== 'number') {\n      return throwError.call(this, 'x and y must be numbers');\n    }\n\n    if (typeof w !== 'number' || typeof h !== 'number') {\n      return throwError.call(this, 'w and h must be numbers');\n    }\n\n    return scanIterator(this, x, y, w, h);\n  }\n}\n\nexport function addConstants(constants, PJWInstance = PJW) {\n  Object.entries(constants).forEach(([name, value]) => {\n    PJWInstance[name] = value;\n  });\n}\n\nexport function addPJWMethods(methods, PJWInstance = PJW) {\n  Object.entries(methods).forEach(([name, value]) => {\n    PJWInstance.prototype[name] = value;\n  });\n}\n\n addConstants(constants);\n addPJWMethods({ composite });\n\nPJW.__extraConstructors = [];\n\n/**\n * Allow client libs to add new ways to build a PJW object.\n * @param {string} name identify the extra constructor.\n * @param {function} test a function that returns true when it accepts the arguments passed to the main constructor.\n * @param {function} run where the magic happens.\n */\nPJW.appendConstructorOption = function(name, test, run) {\n  PJW.__extraConstructors.push({ name, test, run });\n};\n\n/**\n * Read an image from a file or a Buffer. Takes the same args as the constructor\n * @returns {Promise} a promise\n */\nPJW.read = function(...args) {\n  return new Promise((resolve, reject) => {\n    new PJW(...args, (err, image) => {\n      if (err) reject(err);\n      else resolve(image);\n    });\n  });\n};\n\nPJW.create = PJW.read;\n\n// /**\n//  * A static helper method that converts RGBA values to a single integer value\n//  * @param {number} r the red value (0-255)\n//  * @param {number} g the green value (0-255)\n//  * @param {number} b the blue value (0-255)\n//  * @param {number} a the alpha value (0-255)\n//  * @param {function(Error, PJW)} cb (optional) A callback for when complete\n//  * @returns {number} an single integer colour value\n//  */\n// PJW.rgbaToInt = function(r, g, b, a, cb) {\n//   if (\n//     typeof r !== 'number' ||\n//     typeof g !== 'number' ||\n//     typeof b !== 'number' ||\n//     typeof a !== 'number'\n//   ) {\n//     return throwError.call(this, 'r, g, b and a must be numbers', cb);\n//   }\n\n//   if (r < 0 || r > 255) {\n//     return throwError.call(this, 'r must be between 0 and 255', cb);\n//   }\n\n//   if (g < 0 || g > 255) {\n//     throwError.call(this, 'g must be between 0 and 255', cb);\n//   }\n\n//   if (b < 0 || b > 255) {\n//     return throwError.call(this, 'b must be between 0 and 255', cb);\n//   }\n\n//   if (a < 0 || a > 255) {\n//     return throwError.call(this, 'a must be between 0 and 255', cb);\n//   }\n\n//   r = Math.round(r);\n//   b = Math.round(b);\n//   g = Math.round(g);\n//   a = Math.round(a);\n\n//   const i =\n//     r * Math.pow(256, 3) +\n//     g * Math.pow(256, 2) +\n//     b * Math.pow(256, 1) +\n//     a * Math.pow(256, 0);\n\n//   if (isNodePattern(cb)) {\n//     cb.call(this, null, i);\n//   }\n\n//   return i;\n// };\n\n// /**\n//  * A static helper method that converts RGBA values to a single integer value\n//  * @param {number} i a single integer value representing an RGBA colour (e.g. 0xFF0000FF for red)\n//  * @param {function(Error, PJW)} cb (optional) A callback for when complete\n//  * @returns {object} an object with the properties r, g, b and a representing RGBA values\n//  */\n// PJW.intToRGBA = function(i, cb) {\n//   if (typeof i !== 'number') {\n//     return throwError.call(this, 'i must be a number', cb);\n//   }\n\n//   const rgba = {};\n\n//   rgba.r = Math.floor(i / Math.pow(256, 3));\n//   rgba.g = Math.floor((i - rgba.r * Math.pow(256, 3)) / Math.pow(256, 2));\n//   rgba.b = Math.floor(\n//     (i - rgba.r * Math.pow(256, 3) - rgba.g * Math.pow(256, 2)) /\n//       Math.pow(256, 1)\n//   );\n//   rgba.a = Math.floor(\n//     (i -\n//       rgba.r * Math.pow(256, 3) -\n//       rgba.g * Math.pow(256, 2) -\n//       rgba.b * Math.pow(256, 1)) /\n//       Math.pow(256, 0)\n//   );\n\n//   if (isNodePattern(cb)) {\n//     cb.call(this, null, rgba);\n//   }\n\n//   return rgba;\n// };\n\n// /**\n//  * Converts a css color (Hex, 8-digit (RGBA) Hex, RGB, RGBA, HSL, HSLA, HSV, HSVA, Named) to a hex number\n//  * @param {string} cssColor a number\n//  * @returns {number} a hex number representing a color\n//  */\n// PJW.cssColorToHex = function(cssColor) {\n//   cssColor = cssColor || 0; // 0, null, undefined, NaN\n\n//   if (typeof cssColor === 'number') return Number(cssColor);\n\n//   return parseInt(tinyColor(cssColor).toHex8(), 16);\n// };\n\n/**\n * Limits a number to between 0 or 255\n * @param {number} n a number\n * @returns {number} the number limited to between 0 or 255\n */\nPJW.limit255 = function(n) {\n  n = Math.max(n, 0);\n  n = Math.min(n, 255);\n\n  return n;\n};\n\n/**\n * Diffs two images and returns\n * @param {PJW} img1 a PJW image to compare\n * @param {PJW} img2 a PJW image to compare\n * @param {number} threshold (optional) a number, 0 to 1, the smaller the value the more sensitive the comparison (default: 0.1)\n * @returns {object} an object { percent: percent similar, diff: a PJW image highlighting differences }\n */\n// PJW.diff = function(img1, img2, threshold = 0.1) {\n//   if (!(img1 instanceof PJW) || !(img2 instanceof PJW))\n//     return throwError.call(this, 'img1 and img2 must be an PJW images');\n\n//   const bmp1 = img1.bitmap;\n//   const bmp2 = img2.bitmap;\n\n//   if (bmp1.width !== bmp2.width || bmp1.height !== bmp2.height) {\n//     if (bmp1.width * bmp1.height > bmp2.width * bmp2.height) {\n//       // img1 is bigger\n//       img1 = img1.cloneQuiet().resize(bmp2.width, bmp2.height);\n//     } else {\n//       // img2 is bigger (or they are the same in area)\n//       img2 = img2.cloneQuiet().resize(bmp1.width, bmp1.height);\n//     }\n//   }\n\n//   if (typeof threshold !== 'number' || threshold < 0 || threshold > 1) {\n//     return throwError.call(this, 'threshold must be a number between 0 and 1');\n//   }\n\n//   const diff = new PJW(bmp1.width, bmp1.height, 0xffffffff);\n\n//   const numDiffPixels = pixelMatch(\n//     bmp1.data,\n//     bmp2.data,\n//     diff.bitmap.data,\n//     diff.bitmap.width,\n//     diff.bitmap.height,\n//     { threshold }\n//   );\n\n//   return {\n//     percent: numDiffPixels / (diff.bitmap.width * diff.bitmap.height),\n//     image: diff\n//   };\n// };\n\n/**\n * Calculates the hamming distance of two images based on their perceptual hash\n * @param {PJW} img1 a PJW image to compare\n * @param {PJW} img2 a PJW image to compare\n * @returns {number} a number ranging from 0 to 1, 0 means they are believed to be identical\n */\n// PJW.distance = function(img1, img2) {\n//   const phash = new ImagePHash();\n//   const hash1 = phash.getHash(img1);\n//   const hash2 = phash.getHash(img2);\n\n//   return phash.distance(hash1, hash2);\n// };\n\n/**\n * Calculates the hamming distance of two images based on their perceptual hash\n * @param {hash} hash1 a pHash\n * @param {hash} hash2 a pHash\n * @returns {number} a number ranging from 0 to 1, 0 means they are believed to be identical\n */\n// PJW.compareHashes = function(hash1, hash2) {\n//   const phash = new ImagePHash();\n\n//   return phash.distance(hash1, hash2);\n// };\n\n/**\n * Compute color difference\n * 0 means no difference, 1 means maximum difference.\n * @param {number} rgba1:    first color to compare.\n * @param {number} rgba2:    second color to compare.\n * Both parameters must be an color object {r:val, g:val, b:val, a:val}\n * Where `a` is optional and `val` is an integer between 0 and 255.\n * @returns {number} float between 0 and 1.\n */\n// PJW.colorDiff = function(rgba1, rgba2) {\n//   const pow = n => Math.pow(n, 2);\n//   const { max } = Math;\n//   const maxVal = 255 * 255 * 3;\n\n//   if (rgba1.a !== 0 && !rgba1.a) {\n//     rgba1.a = 255;\n//   }\n\n//   if (rgba2.a !== 0 && !rgba2.a) {\n//     rgba2.a = 255;\n//   }\n\n//   return (\n//     (max(pow(rgba1.r - rgba2.r), pow(rgba1.r - rgba2.r - rgba1.a + rgba2.a)) +\n//       max(pow(rgba1.g - rgba2.g), pow(rgba1.g - rgba2.g - rgba1.a + rgba2.a)) +\n//       max(pow(rgba1.b - rgba2.b), pow(rgba1.b - rgba2.b - rgba1.a + rgba2.a))) /\n//     maxVal\n//   );\n// };\n\n/**\n * Helper to create PJW methods that emit events before and after its execution.\n * @param {string} methodName   The name to be appended to PJW prototype.\n * @param {string} evName       The event name to be called.\n *                     It will be prefixed by `before-` and emitted when on method call.\n *                     It will be appended by `ed` and emitted after the method run.\n * @param {function} method       A function implementing the method itself.\n * It will also create a quiet version that will not emit events, to not\n * mess the user code with many `changed` event calls. You can call with\n * `methodName + \"Quiet\"`.\n *\n * The emitted event comes with a object parameter to the listener with the\n * `methodName` as one attribute.\n */\nexport function PJWEvMethod(methodName, evName, method) {\n  const evNameBefore = 'before-' + evName;\n  const evNameAfter = evName.replace(/e$/, '') + 'ed';\n\n  PJW.prototype[methodName] = function(...args) {\n    let wrappedCb;\n    const cb = args[method.length - 1];\n    const PJWInstance = this;\n\n    if (typeof cb === 'function') {\n      wrappedCb = function(...args) {\n        const [err, data] = args;\n\n        if (err) {\n          PJWInstance.emitError(methodName, err);\n        } else {\n          PJWInstance.emitMulti(methodName, evNameAfter, {\n            [methodName]: data\n          });\n        }\n\n        cb.apply(this, args);\n      };\n\n      args[args.length - 1] = wrappedCb;\n    } else {\n      wrappedCb = false;\n    }\n\n    this.emitMulti(methodName, evNameBefore);\n\n    let result;\n\n    try {\n      result = method.apply(this, args);\n\n      if (!wrappedCb) {\n        this.emitMulti(methodName, evNameAfter, {\n          [methodName]: result\n        });\n      }\n    } catch (error) {\n      error.methodName = methodName;\n      this.emitError(methodName, error);\n    }\n\n    return result;\n  };\n\n  PJW.prototype[methodName + 'Quiet'] = method;\n}\n\n/**\n * Creates a new image that is a clone of this one.\n * @param {function(Error, PJW)} cb (optional) A callback for when complete\n * @returns the new image\n */\nPJWEvMethod('clone', 'clone', function(cb) {\n  const clone = new PJW(this);\n\n  if (isNodePattern(cb)) {\n    cb.call(clone, null, clone);\n  }\n\n  return clone;\n});\n\n/**\n * Simplify PJWEvMethod call for the common `change` evName.\n * @param {string} methodName name of the method\n * @param {function} method to watch changes for\n */\nexport function PJWEvChange(methodName, method) {\n  PJWEvMethod(methodName, 'change', method);\n}\n\n/**\n * Sets the type of the image (RGB or RGBA) when saving as PNG format (default is RGBA)\n * @param b A Boolean, true to use RGBA or false to use RGB\n * @param {function(Error, PJW)} cb (optional) a callback for when complete\n * @returns {PJW} this for chaining of methods\n */\nPJWEvChange('background', function(hex, cb) {\n  if (typeof hex !== 'number') {\n    return throwError.call(this, 'hex must be a hexadecimal rgba value', cb);\n  }\n\n  this._background = hex;\n\n  if (isNodePattern(cb)) {\n    cb.call(this, null, this);\n  }\n\n  return this;\n});\n\n/**\n * Scans through a region of the bitmap, calling a function for each pixel.\n * @param {number} x the x coordinate to begin the scan at\n * @param {number} y the y coordinate to begin the scan at\n * @param w the width of the scan region\n * @param h the height of the scan region\n * @param f a function to call on even pixel; the (x, y) position of the pixel\n * and the index of the pixel in the bitmap buffer are passed to the function\n * @param {function(Error, PJW)} cb (optional) a callback for when complete\n * @returns {PJW} this for chaining of methods\n */\nPJWEvChange('scan', function(x, y, w, h, f, cb) {\n  if (typeof x !== 'number' || typeof y !== 'number') {\n    return throwError.call(this, 'x and y must be numbers', cb);\n  }\n\n  if (typeof w !== 'number' || typeof h !== 'number') {\n    return throwError.call(this, 'w and h must be numbers', cb);\n  }\n\n  if (typeof f !== 'function') {\n    return throwError.call(this, 'f must be a function', cb);\n  }\n\n  const result = scan(this, x, y, w, h, f);\n\n  if (isNodePattern(cb)) {\n    cb.call(this, null, result);\n  }\n\n  return result;\n});\n\nif (process.env.ENVIRONMENT === 'BROWSER') {\n  // For use in a web browser or web worker\n  /* global self */\n  let gl;\n\n  if (typeof window !== 'undefined' && typeof window === 'object') {\n    gl = window;\n  }\n\n  if (typeof self !== 'undefined' && typeof self === 'object') {\n    gl = self;\n  }\n\n  gl.PJW = PJW;\n  gl.Buffer = Buffer;\n}\n\nexport { addType } from './utils/mime';\n\nexport default PJW;\n"],"file":"index.js"}